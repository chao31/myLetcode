## sdk

### 流程

```js
Promise.all([getConfigData(), getActivityData()])

store.commit('setRootState', {key: 'configData', value: msg})

// 容器 component 检测到 store 有组件列表后，for 循环加载 component
<component 
    :is="comp.cls"
    v-for="(comp, comsIndex) in comLists"
>
```

### 组件按需加载

所有 `js` 模块 打包成一个 `bundle.js` 太大了，可以把某些 `js模块` 单独打包，等要用到的时候，`webpack` 自动创建 `script` 标签去请求这个 `js 文件`

1. `require.ensure()`：主要用于实现代码打包分离文件，`require.ensure()` 是 `webpack` 特有的

```js
require.ensure(
    [], // 依赖
    () => {// 回调函数，在这里按需引入模块和处理逻辑
        require('@/components/home')
    }, 
    'demo') // webpackChunk 名，同名的打包进同个 bundle
```

2. `import()`：`Webpack` 会将任何一个`异步模块`与相同的块名称`组合`到相同的异步块中。

```js
// 下面 2 行代码，没有指定 webpackChunkName，每个组件打包成一个 js 文件。
const ImportFuncDemo1 = () => import('../components/ImportFuncDemo1')
const ImportFuncDemo2 = () => import('../components/ImportFuncDemo2')

// 下面 2 行代码，指定了相同的 webpackChunkName，会合并打包成一个 js 文件。
const ImportFuncDemo = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/ImportFuncDemo')
const ImportFuncDemo2 = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/ImportFuncDemo2')

```

## 项目经历

遇到过的问题：

### 红包雨

1. 如果用 `setInterval` 每隔 `10ms` 倒计时一次，浏览器在不可见的时候，倒计时会暂停（500ms 以内的频率会出现），等可见以后倒计时继续

```js
var rainEndTime = rainStartTime + duration;
TIMER_CLOCK = setInterval(function() {
    var now = new Date().getTime();
    duration = rainEndTime - now;
    var timeArr = duration/1000;
    timeArr = timeArr.toFixed(2).toString().split('');
    self.time = timeArr;
    if (duration <= 0) {
        self.stop();
    }
}, 10);
```
2. 点中红包，机会 +1，发请求，但 500 毫秒内只会触发一次 (节流函数)
3. `防刷量`,唯一 id+服务端给的时间戳，简单的算法只有前后端知道
```js
// 使用 identifier+时间戳加密，生成一个 token，服务端解析后，根据时间戳是否在正常区间来判断是否刷量
ajaxData.token = md5Hex(identifier + timeStamps);
```

### 动画

手写复杂动画，以及 vue-lottie，json 文件 10k 左右

### 首屏优化 

- feed 流页面，从 `localstorage` 里取出缓存的前 4 个组件（已占满一屏），同时异步请求，等请求回来，更新缓存页面，闪一下，并更新缓存，在$nextTick 的 callback 里渲染剩下组件（下一屏）,`$nextTick` 定义：在下次 `DOM` 更新循环结束之后执行延迟回调
- performance.timing 测试白屏时间从

`performance.timing`:白屏时间 (`t.responseStart - t.navigationStart`)

```js
window.onload = function(){
    setTimeout(function(){
        let t = performance.timing
        console.log('DNS 查询耗时：' + (t.domainLookupEnd - t.domainLookupStart).toFixed(0))
        console.log('TCP 链接耗时：' + (t.connectEnd - t.connectStart).toFixed(0))
        console.log('request 请求耗时：' + (t.responseEnd - t.responseStart).toFixed(0))
        console.log('解析 dom 树耗时：' + (t.domComplete - t.domInteractive).toFixed(0))
        console.log('白屏时间：' + (t.responseStart - t.navigationStart).toFixed(0))
        console.log('domready 时间：' + (t.domContentLoadedEventEnd - t.navigationStart).toFixed(0))
        console.log('onload 时间：' + (t.loadEventEnd - t.navigationStart).toFixed(0))

        if(t = performance.memory){
            console.log('js 内存使用占比：' + (t.usedJSHeapSize / t.totalJSHeapSize * 100).toFixed(2) + '%')
        }
    })
}
```





