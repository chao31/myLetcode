## sdk

### 流程

```js
Promise.all([getConfigData(), getActivityData()])

store.commit('setRootState', {key: 'configData', value: msg})

// 容器 component 检测到 store 有组件列表后，for 循环加载 component
<component 
    :is="comp.cls"
    v-for="(comp, comsIndex) in comLists"
>
```

### 组件按需加载

所有 `js` 模块 打包成一个 `bundle.js` 太大了，可以把某些 `js模块` 单独打包，等要用到的时候，`webpack` 自动创建 `script` 标签去请求这个 `js 文件`

1. `require.ensure()`：主要用于实现代码打包分离文件，`require.ensure()` 是 `webpack` 特有的

```js
require.ensure(
    [], // 依赖
    () => {// 回调函数，在这里按需引入模块和处理逻辑
        require('@/components/home')
    }, 
    'demo') // webpackChunk 名，同名的打包进同个 bundle
```

2. `import()`：`Webpack` 会将任何一个`异步模块`与相同的块名称`组合`到相同的异步块中。

```js
// 下面 2 行代码，没有指定 webpackChunkName，每个组件打包成一个 js 文件。
const ImportFuncDemo1 = () => import('../components/ImportFuncDemo1')
const ImportFuncDemo2 = () => import('../components/ImportFuncDemo2')

// 下面 2 行代码，指定了相同的 webpackChunkName，会合并打包成一个 js 文件。
const ImportFuncDemo = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/ImportFuncDemo')
const ImportFuncDemo2 = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/ImportFuncDemo2')

```

## 项目经历

遇到过的问题：

### 红包雨

1. 如果用 `setInterval` 每隔 `10ms` 倒计时一次，浏览器在不可见的时候，倒计时会暂停（500ms 以内的频率会出现），等可见以后倒计时继续

```js
var rainEndTime = rainStartTime + duration;
TIMER_CLOCK = setInterval(function() {
    var now = new Date().getTime();
    duration = rainEndTime - now;
    var timeArr = duration/1000;
    timeArr = timeArr.toFixed(2).toString().split('');
    self.time = timeArr;
    if (duration <= 0) {
        self.stop();
    }
}, 10);
```
2. 点中红包，机会 +1，发请求，但 500 毫秒内只会触发一次 (节流函数)
3. `防刷量`,唯一 id+服务端给的时间戳，简单的算法只有前后端知道
```js
// 使用 identifier+时间戳加密，生成一个 token，服务端解析后，根据时间戳是否在正常区间来判断是否刷量
ajaxData.token = md5Hex(identifier + timeStamps);
```

### 动画

手写复杂动画，以及 vue-lottie，json 文件 10k 左右

### 首屏优化 

`vue 的异步组件`和 webpack 的`代码分割功能`，实现组件的懒加载，该做的已经做了，剩下的只有结合业务特点，`在 IO 瓶颈，海外印度，4g 网下`，进行优化，我们是 feed 流页面...


- feed 流页面，从 `localstorage` 里取出缓存的前 4 个组件（已占满一屏），同时异步请求，等请求回来，更新缓存页面，闪一下，并更新缓存，在$nextTick 的 callback 里渲染剩下组件（下一屏）,`$nextTick` 定义：在下次 `DOM` 更新循环结束之后执行延迟回调
- `performance.timing` 测试白屏时间，提升了 80%，达到了国内一样的速度，dau 打到了突破了 1000w

`performance.timing`:白屏时间 (`t.responseStart - t.navigationStart`)

```js
window.onload = function(){
    setTimeout(function(){
        let t = performance.timing
        console.log('DNS 查询耗时：' + (t.domainLookupEnd - t.domainLookupStart).toFixed(0))
        console.log('TCP 链接耗时：' + (t.connectEnd - t.connectStart).toFixed(0))
        console.log('request 请求耗时：' + (t.responseEnd - t.responseStart).toFixed(0))
        console.log('解析 dom 树耗时：' + (t.domComplete - t.domInteractive).toFixed(0))
        console.log('白屏时间：' + (t.responseStart - t.navigationStart).toFixed(0))
        console.log('domready 时间：' + (t.domContentLoadedEventEnd - t.navigationStart).toFixed(0))
        console.log('onload 时间：' + (t.loadEventEnd - t.navigationStart).toFixed(0))

        if(t = performance.memory){
            console.log('js 内存使用占比：' + (t.usedJSHeapSize / t.totalJSHeapSize * 100).toFixed(2) + '%')
        }
    })
}
```

### 国内优化

打包分析：利用 `webpack-bundle-analyzer` 分析器，分析项目依赖关系。

1. 针对体积比较大的一些钢需依赖，选择 CDN 加速的方式
2. 配置 webpack 来分离 echarts
```js
module.exports = {
     externals: { //externals 里的库不会被 webpack 打包
   	    echarts: 'echarts',
     },   
}
```
在需要使用依赖的地方 import 进来就可以。

- [首屏加载慢优化 (性能优化)](https://juejin.cn/post/6869203659272486926)
- [关于首屏优化，我做了哪些](https://juejin.cn/post/7117515006714839047)

## 为什么离职

devopts 做的领域局限性比较大

降本增效，不再研发新的项目，老项目维护，只留 2 个人

常用 hooks：useState、useDispatch、useSelector

  const articleState = useSelector((state: RootState) => state.articleReducer);

## devops

devops 双环模型：代码静态检查、单元测试、构建，打包，部署

功能：

1. 上传测试报告（为什么自己开发自己的测试报告，jest 官方报告不能满足我们的需求，还有一些数据没有，比如增量测试用例等等）
2. 远程调度能力（老旧的大型项目，流水线要跑 1 个小时，本地跑 mac 卡，啥也干不了，所以放到远程去跑）
3. 初始化配置，类似 vue-cli，react 脚手架（create-react-app）,自动生成 jest 配置文件，零配置成本
4. 



