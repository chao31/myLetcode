
## 扁平 path 从 object 取值

示例：

```js
// 示例
var object = { a: [{ b: { c: 3 } }] }; // path: 'a[0].b.c'
var array = [{ a: { b: [1] } }]; // path: '[0].a.b[0]'
```

实现：

```js
const get = (from, ...selectors) =>
  [...selectors].map(s =>
    s
      // 标准答案里的正则匹配应该这样，/\[([^\[\]]*)\]/g，下面是简化版
      .replace(/\[(.+)\]/g, '.$1.')
      .split('.')
      .filter(t => t !== '')
      .reduce((prev, cur) => prev && prev[cur], from)
  );

// Examples
const obj = {
  selector: { to: { val: 'val to select' } },
  target: [1, 2, { a: 'test' }],
};
get(obj, 'selector.to.val', 'target[0]', 'target[2].a'); // ['val to select', 1, 'test']
```

分析一下标准答案的正则——`/\[([^\[\]]*)\]/g`:

1. 匹配`[]`，用`\[`与`\]`
2. 匹配`[xxx]`里的东西`xxx`,用分组`()`
3. `xxx` 不能是`\[`与`\]`，用 [^abc],查找任何不在方括号之间的字符
4. `xxx` 的数量 0 或多个，用`*`
5. 最后，`$1`表被匹配到的 `xxx`

简单点做，我用的`/\[(.)\]/g`来匹配

## Object 扁平化

实现：`{ a: { b: { c: 1 } }, d: 1 }))` -->  `{a.b.c: 1, d: 1}`

```js
const flattenObject = (obj, prefix = '', newObj = {}) => { 
  Object.keys(obj).forEach((key) => {
    const pre = prefix ? `${prefix}.${key}`: key;
    if(typeof obj[key] === 'object' && obj[key] !== null) {
      flattenObject(obj[key], pre, newObj);
    }else {
      newObj[pre] = obj[key];
    }
  });
  return newObj;
};

console.log(flattenObject({ a: { b: { c: 1 } }, d: 1 })); // {a.b.c: 1, d: 1}
```
