## 最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

## 示例

### 示例 1

```js
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

### 示例 2

```js
输入：s = "cbbd"
输出："bb"
```

## 解题思路

使用`扩展中心算法`，分`偶数对称`和`奇数对称`，但处理都一样：

- 偶数对称：左右从 `[index, index +1]` 开始的，index = 0，分别向左右两边移动指针
- 奇数对称：左右从 `[index, index]` 开始的，index = 0，分别向左右两边移动指针

### while 循环

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    let maxLen = 0;
    let start = 0;
    let end = 0;

    for(let i =0; i< s.length; i++) {
        // 偶数对称
        expandCenter(i, i+1);
        // 奇数对称
        expandCenter(i, i);
    }
    return s.slice(start, end + 1);

    function expandCenter(left, right) {
        if(s[left] !== s[right]) return; 

        while(0 <= left && right < s.length && s[left] === s[right]) {
            left--;
            right++;
        }
        // 经过 while 后的 left、right 一定不符合条件，但上一轮 left、right 一定是正确的，所以回退一下
        left++;
        right--;

        const len = right - left + 1;
        if(len > maxLen) {
            maxLen = len;
            start = left;
            end = right;
        }
        
    }
};
```

### 递归

```javascript
var longestPalindrome = function(s) {
    let maxLen = 0;
    let startL = 0;
    let endR = 0;

    for(let i =0; i< s.length; i++) {
        // 偶数对称
        expandCenter(i, i+1);
        // 奇数对称
        expandCenter(i, i);
    }
    return s.slice(startL, endR + 1);

    function expandCenter(left, right) {
        if(0 > left || right >= s.length || s[left] !== s[right]) {
            return;
        }

        const len = right - left + 1;
        if(len > maxLen) {
            maxLen = len;
            startL = left;
            endR = right;
        }

        // 此处这样写就会有大问题 expandCenter(left--, right++);
        expandCenter(--left, ++right);
    }
};
```

----

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/longest-palindromic-substring
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。