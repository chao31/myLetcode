## 最短回文串

给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

## 示例

### 示例 1

```js
输入：s = "aacecaaa"
输出："aaacecaaa"
```

### 示例 2

```js
输入：s = "abcd"
输出："dcbabcd"
```

## 暴力解法，熟悉一下扩展中心算法即可

使用扩展中心算法，分奇数和偶数，找前缀中最长对称字符串

### 代码

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var shortestPalindrome = function(s) {
    if(s === '') return '';

    const len = s.length;
    let isEven = len % 2 === 0;
    // s 是偶数、奇数分开处理
    if(isEven) {
        for(let i = (len / 2 - 1);i >= 0; i--) {
            // 偶数对称中心
            if(expandCenter(i, i+1)) {
                return s.slice((i + 1) * 2).split('').reverse().join('') + s; 
            } 
            // 奇数对称中心
            if(expandCenter(i,i)) {
                return s.slice(i * 2 + 1).split('').reverse().join('') + s; 
            }
        }
        
        
    }else {
        for(let i = Math.floor(len / 2);i >= 0; i--) {
            // 奇数对称中心
            if(expandCenter(i,i)) {
                return s.slice(i * 2 + 1).split('').reverse().join('') + s; 
            }

            // 偶数对称中心
            if(expandCenter(i-1, i)) {
                return s.slice(i * 2).split('').reverse().join('') + s; 
            } 
        }
    }

    function expandCenter(left, right) {
        while(0 <= left && right < s.length && s[left] === s[right]) {
            --left;
            ++right;
        }
        return left === -1;
    }
};
```

## kmp 算法

下面方法只选取了 kmp 算法的一部分，具体是可以看这个[视频](https://www.bilibili.com/video/BV1Px411z7Yo?from=search&seid=17279757832220900358)学习完整的 kmp 算法

### code

```js
/**
 * @param {string} s
 * @return {string}
 */
var shortestPalindrome = function(s) {
    // 1. 回文串有个特点，反过来后也能和原串重叠
    // 2. 因为 s 是这样构成：回文串 + 后缀，所以 str 就是这样：回文串 + 后缀 + ' ' + 反转后缀 + 回文串
    // 3. 用 kmp 算法，找到公共前缀和后缀，就是回文串
    const s2 = s.split('').reverse().join('');
    const str = s + ' ' + s2;
    
    // 这是 kmp 算法的一部分，next 数组里保存了每个子串的最长公共前后缀的长度
    // 1. new 一个 next 数组，长度和 str 一样，里面用 0 占位
    // 2. i 指针遍历字符串，len 指针是当前 i 要对比的元素的 index
    // 3. next 数组里面存放的 len 有两个作用：
    //（1）对应 i 的最长的公共前后缀的长度 
    //（2）下一个字符需要进行对比的元素在原串中的 index
    const kmp = function(str) {
        let i = 1;
        let len = 0;
        const next = new Array(str.length).fill(0);

        while(i < str.length) {
            if(str[i] === str[len]) {
                len++;
                // 找到结果，存放len，开始下一次循环
                next[i] = len;
                i++;
            }else {
                if(len > 0) {
                    // 巡回往回找 len - 1 这个元素是否符合
                    len = next[len - 1]
                }else {
                    // 找到结果，存放 len，开始下一次循环
                    next[i] = 0;
                    i++;
                }

            }
        }

        return next;
    }

    const next = kmp(str);
    const maxLen = next[str.length - 1];
    const prefix = s.slice(maxLen).split('').reverse().join('');
    return prefix + s;
};
```

-----

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/shortest-palindrome
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。